\documentclass[a4paper]{scrartcl}
\usepackage[l2tabu,orthodox]{nag}% Old habits die hard. All the same, there are commands, classes and packages which are outdated and superseded. nag provides routines to warn the user about the use of those.

\usepackage[all,error]{onlyamsmath}% Error on deprecated math commands like $$ $$.
\usepackage{listings}
\title{COMP2911}
\lstset{language=JAVA}
\author{Minjie Shen}

\newcommand{\aggregates}{$\diamondsuit\rightarrow $}
\newcommand{\implements}{\textendash ~\textendash ~\textendash$\triangleright$}
\newcommand{\extends}{\textendash\textendash\textendash$\triangleright$}
\newcommand{\uses}{$\longrightarrow$}

\begin{document}
  \maketitle
  \section{Object Oriented Design}
    \subsection {Law of Demeter}
      \begin{itemize}
        \item Each unit should have only limited knowledge about other units: only units "closely" related to the current unit.
        \item Each unit should only talk to its friends; don't talk to strangers.
        \item Only talk to your immediate friends.
      \end{itemize}
      
    \subsection { Liskov Principle }
      If S extends T, then objects of type T can be replaced with objects of type S with no adverse effects
    
    \subsection { UML }
      Unified Modeling Language makes it possible to describe systems with words and pictures. Especially notable use case diagrams with their stick figures or the widely used class diagrams.
  \section{Programming By Contract}
    \subsection { Covariance and Contravariance}
      Assume B \extends A
      \subsubsection{Convariance}
        B.method() refines A.method by s-post
      \subsubsection{Contravariance}
        B.method() refines A.method by w-pre
    \subsection {Class Invariant}
      Property that always holds before and after each operation inside the class.\\
      Implicitly contained inside each pre and postcondition of all the methods.
       
       
   
  \section{Generic Type \& Polynorphism}
    \subsection {Polymorphism}
      Polymorphism is the ability to treat an object of any subclass of a base class as if it were an object of the base class.

    \subsection {Set type}
      \lstinputlisting{code/Set.java}
    
    ArrayListSet type
    \lstinputlisting{code/ArrayListSet.java}
    
  \section{Design pattern}
    \subsection {Design Pattern }
      Patterns are higher-order designs, which occur repeatedly in object-oriented design. They have been formalized, and are generally considered a good development practice.
    \subsection { Refactoring }
      Refactoring is a disciplined technique for restructuring an existing body of code, altering its internal structure without changing its external behavior.
    \subsection { Iterator Pattern }
      \subsubsection {Motivation}
        Access elements of a collection without exposing internal structure.
      \subsubsection { Intent }
        Provide a way to access the elements of an aggregate object sequentially without exposing its underly representation.
      \subsubsection { Implementation }
        Client \aggregates Aggregate( +createIterator(): Iterator )\\
        ConcreteAggregate \implements Aggregate\\
        ConcreteIterator \implements Iterator\\
        Client \uses Iterator\\
        \lstinputlisting{code/iter.java}
        
    \subsection { Strategy Pattern }
      \subsubsection {Motivation}
        Common situations when classes differ only in their behavior. Have ability to select algorithms at runtime.
      \subsubsection {Intent}
        Define a family of algorithms, encapsulate each one, and make them interchangeable
      \subsubsection { Implementation }
        Context \aggregates Strategy (+BehaviorInterface())\\
        ConcreteStrategy \implements Strategy\\
        \lstinputlisting{code/strategy.java}
        
    \subsection{Observer Pattern}
      \subsubsection{Motivation}
        The cases when certain objects need to be informed about the changes occured in other objects are frequent.
      \subsubsection{Intent}
        Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
      \subsubsection{Implementation}
        Observable \aggregates Observer (+update():void)\\
        ConcreteObservable \extends Observable\\
        \lstinputlisting{code/observer.java}
        
    \subsection { Decorator Pattern }
      \subsubsection {Motivation}
        Might be necessary to extend an object's functionality dynamically at run time while it's used.
      \subsubsection {Intention }
        The intent of this pattern is to add additional responsibilities dynamically to an object.
      \subsubsection{Implementation}
        ConcreteComponent \implements Component(+doOperation())\\
        Decorator \implements Component\\
        Decorator \aggregates a Component\\
        ConcreteDecoratorExtendingState \extends Decorator\\
        \lstinputlisting{code/decorator.java}
        
    \subsection { Composite Pattern}
      \subsubsection {Motivation}
        Implement tree structure classes
      \subsubsection {Intention }
        Treat each element uniformly and to compose objects into tree structures
      \subsubsection{Implementation}
        Client \uses Component\\
        Leaf \implements Component \\
        Composite \implements Component \\
        Composite \aggregates Component \\
        
        \lstinputlisting{code/composite.java}
\end{document}
